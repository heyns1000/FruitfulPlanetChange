name: ğŸ”„ Cross-Repository Synchronization

on:
  push:
    branches:
      - '**'  # Trigger on all branches
  schedule:
    # Run every 15 minutes for continuous synchronization
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Specific branch to sync (leave empty for all branches)'
        required: false
        default: ''
      force_sync:
        description: 'Force full synchronization'
        required: false
        type: boolean
        default: false
      sync_strategy:
        description: 'Sync strategy'
        required: false
        type: choice
        options:
          - auto
          - fast-forward-only
          - merge
        default: auto

env:
  ECOSYSTEM_CONFIG: '.github/ecosystem-config.json'

jobs:
  detect-changes:
    name: ğŸ” Detect Branch Changes
    runs-on: ubuntu-latest
    outputs:
      branches_to_sync: ${{ steps.detect.outputs.branches }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
      sync_mode: ${{ steps.detect.outputs.sync_mode }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          submodules: false  # Explicitly disable automatic submodule updates

      - name: Check for submodule configuration
        id: check_submodules
        continue-on-error: true
        run: |
          echo "ğŸ” Checking for submodule configuration..."
          
          if [[ -f ".gitmodules" ]]; then
            echo "ğŸ“‹ .gitmodules file found, validating..."
            echo "has_submodules=true" >> $GITHUB_OUTPUT
            
            # Validate submodule URLs
            while IFS= read -r line; do
              if [[ "$line" =~ ^[[:space:]]*url[[:space:]]*=[[:space:]]*(.+)$ ]]; then
                URL="${BASH_REMATCH[1]}"
                echo "  Checking URL: $URL"
                
                # Validate URL format
                if [[ "$URL" =~ ^(https://|git@) ]]; then
                  echo "  âœ… Valid URL format"
                else
                  echo "  âš ï¸ Warning: Potentially invalid URL format"
                fi
              fi
            done < .gitmodules
          else
            echo "â„¹ï¸ No .gitmodules file found"
            echo "has_submodules=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for orphaned submodule config
          if git config --file .git/config --get-regexp submodule >/dev/null 2>&1; then
            echo "âš ï¸ Warning: Submodule config exists in .git/config but no .gitmodules file"
            echo "  This may cause issues. Attempting to clean up..."
            git config --file .git/config --remove-section submodule 2>/dev/null || true
          fi

      - name: Initialize submodules (if needed)
        if: steps.check_submodules.outputs.has_submodules == 'true'
        continue-on-error: true
        run: |
          echo "ğŸ”„ Initializing submodules..."
          
          # Try to initialize submodules with error handling
          if git submodule init; then
            echo "âœ… Submodule initialization successful"
            
            # Attempt to update submodules
            if git submodule update --init --recursive --depth 1 2>&1 | tee /tmp/submodule_update.log; then
              echo "âœ… Submodule update successful"
            else
              echo "âš ï¸ Warning: Submodule update failed, continuing without submodules"
              echo "Error log:"
              cat /tmp/submodule_update.log || true
              
              # Clean up failed submodule state
              git submodule deinit --all -f 2>/dev/null || true
            fi
          else
            echo "âš ï¸ Warning: Submodule initialization failed, continuing without submodules"
          fi

      - name: Detect branches needing sync
        id: detect
        run: |
          echo "ğŸ” Detecting branches to synchronize..."
          
          # Get target branch from input or current branch
          if [[ -n "${{ github.event.inputs.target_branch }}" ]]; then
            TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
            echo "branches=[\"$TARGET_BRANCH\"]" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "sync_mode=manual" >> $GITHUB_OUTPUT
            echo "ğŸ“Œ Manual sync for branch: $TARGET_BRANCH"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            # Sync the pushed branch
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            echo "branches=[\"$BRANCH_NAME\"]" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "sync_mode=push" >> $GITHUB_OUTPUT
            echo "ğŸ“¤ Push detected on branch: $BRANCH_NAME"
          elif [[ "${{ github.event_name }}" == "schedule" ]] || [[ "${{ github.event.inputs.force_sync }}" == "true" ]]; then
            # Sync all active branches
            BRANCHES=$(git branch -r | grep -v HEAD | sed 's/origin\///' | grep -E '^(copilot|claude|main|develop)' | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "branches=$BRANCHES" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "sync_mode=scheduled" >> $GITHUB_OUTPUT
            echo "â° Scheduled sync for all branches"
          else
            echo "branches=[]" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "sync_mode=none" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No sync needed"
          fi

  sync-to-codenest:
    name: ğŸ¦ Sync to CodeNest
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        branch: ${{ fromJson(needs.detect-changes.outputs.branches_to_sync) }}
      fail-fast: false
      max-parallel: 5
    steps:
      - name: Checkout FruitfulPlanetChange
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.branch }}
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          submodules: false  # Explicitly disable automatic submodule updates

      - name: Setup Git
        run: |
          git config --global user.name "HSOMNI9000 Sync Bot"
          git config --global user.email "sync-bot@fruitfulplanet.com"

      - name: Validate repository state
        id: validate
        continue-on-error: true
        run: |
          echo "ğŸ” Validating repository state..."
          
          # Check for submodule issues
          if [[ -f ".gitmodules" ]]; then
            echo "ğŸ“‹ Submodules detected, checking configuration..."
            
            # Validate each submodule URL
            while IFS= read -r line; do
              if [[ "$line" =~ ^[[:space:]]*url[[:space:]]*=[[:space:]]*(.+)$ ]]; then
                URL="${BASH_REMATCH[1]}"
                echo "  Validating URL: $URL"
                
                # Check if URL is accessible (basic validation)
                if [[ "$URL" =~ ^https:// ]]; then
                  # For HTTPS URLs, check format
                  if [[ "$URL" =~ ^https://[^/]+/[^/]+/.+\.git$ ]] || [[ "$URL" =~ ^https://[^/]+/[^/]+/[^/]+$ ]]; then
                    echo "  âœ… URL format valid"
                  else
                    echo "  âš ï¸ URL format may be invalid: $URL"
                  fi
                elif [[ "$URL" =~ ^git@ ]]; then
                  echo "  â„¹ï¸ SSH URL detected: $URL"
                fi
              fi
            done < .gitmodules
            
            echo "has_submodules=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ No submodules configured"
            echo "has_submodules=false" >> $GITHUB_OUTPUT
          fi
          
          # Verify git state is clean
          if git status --porcelain | grep -q '^'; then
            echo "âš ï¸ Working directory has uncommitted changes"
            git status --short
          else
            echo "âœ… Working directory is clean"
          fi
          
          echo "âœ… Repository state validation complete"

      - name: Load ecosystem configuration
        id: config
        run: |
          echo "ğŸ“ Loading ecosystem configuration..."
          if [[ -f "${{ env.ECOSYSTEM_CONFIG }}" ]]; then
            CODENEST_REPO=$(jq -r '.repositories[] | select(.role == "meta-aggregator") | .name' ${{ env.ECOSYSTEM_CONFIG }})
            SYNC_STRATEGY=$(jq -r '.repositories[] | select(.role == "meta-aggregator") | .sync_strategy' ${{ env.ECOSYSTEM_CONFIG }})
            PATH_PREFIX=$(jq -r '.repositories[] | select(.role == "meta-aggregator") | .path_prefix // ""' ${{ env.ECOSYSTEM_CONFIG }})
            
            echo "codenest_repo=$CODENEST_REPO" >> $GITHUB_OUTPUT
            echo "sync_strategy=$SYNC_STRATEGY" >> $GITHUB_OUTPUT
            echo "path_prefix=$PATH_PREFIX" >> $GITHUB_OUTPUT
            
            echo "âœ… Target: $CODENEST_REPO"
            echo "âœ… Strategy: $SYNC_STRATEGY"
            echo "âœ… Path prefix: $PATH_PREFIX"
          else
            echo "âŒ Configuration file not found"
            exit 1
          fi

      - name: Check if branch exists in CodeNest
        id: check_branch
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸ” Checking if branch exists in CodeNest..."
          REPO="${{ steps.config.outputs.codenest_repo }}"
          BRANCH="${{ matrix.branch }}"
          
          # Use GitHub API to check if branch exists
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$REPO/branches/$BRANCH")
          
          if [[ "$STATUS_CODE" == "200" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Branch exists in CodeNest"
          elif [[ "$STATUS_CODE" == "404" ]]; then
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Branch does not exist in CodeNest (will create)"
          else
            echo "exists=unknown" >> $GITHUB_OUTPUT
            echo "âš ï¸ Unable to determine branch status (HTTP $STATUS_CODE)"
          fi

      - name: Sync branch to CodeNest
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸ”„ Syncing branch ${{ matrix.branch }} to CodeNest..."
          
          REPO="${{ steps.config.outputs.codenest_repo }}"
          BRANCH="${{ matrix.branch }}"
          BRANCH_EXISTS="${{ steps.check_branch.outputs.exists }}"
          
          # Skip if branch status is unknown
          if [[ "$BRANCH_EXISTS" == "unknown" ]]; then
            echo "âš ï¸ Skipping sync due to unknown branch status"
            exit 0
          fi
          
          # Get latest commit SHA from current branch
          LATEST_SHA=$(git rev-parse HEAD)
          echo "ğŸ“Œ Latest commit: $LATEST_SHA"
          
          if [[ "$BRANCH_EXISTS" == "false" ]]; then
            # Create new branch in CodeNest
            echo "ğŸŒ± Creating new branch in CodeNest..."
            
            # Get the default branch SHA as base
            DEFAULT_BRANCH=$(curl -s \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO" | jq -r '.default_branch')
            
            BASE_SHA=$(curl -s \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/git/ref/heads/$DEFAULT_BRANCH" | jq -r '.object.sha')
            
            # Create new ref
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/git/refs" \
              -d "{\"ref\":\"refs/heads/$BRANCH\",\"sha\":\"$BASE_SHA\"}"
            
            echo "âœ… Branch created in CodeNest"
          fi
          
          # Trigger repository dispatch to sync changes
          echo "ğŸ“¤ Triggering sync in CodeNest..."
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$REPO/dispatches" \
            -d "{\"event_type\":\"sync_from_fruitful\",\"client_payload\":{\"branch\":\"$BRANCH\",\"source_repo\":\"$GITHUB_REPOSITORY\",\"source_sha\":\"$LATEST_SHA\"}}"
          
          echo "âœ… Sync request sent to CodeNest"

      - name: Record sync event
        if: always()
        run: |
          echo "ğŸ“Š Recording sync event..."
          echo "Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "Branch: ${{ matrix.branch }}"
          echo "Target: CodeNest"
          echo "Status: ${{ job.status }}"

  sync-to-omnigrid:
    name: ğŸ”· Sync to OmniGrid
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        branch: ${{ fromJson(needs.detect-changes.outputs.branches_to_sync) }}
      fail-fast: false
      max-parallel: 5
    steps:
      - name: Checkout FruitfulPlanetChange
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.branch }}
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          submodules: false  # Explicitly disable automatic submodule updates

      - name: Setup Git
        run: |
          git config --global user.name "HSOMNI9000 Sync Bot"
          git config --global user.email "sync-bot@fruitfulplanet.com"

      - name: Validate repository state
        id: validate
        continue-on-error: true
        run: |
          echo "ğŸ” Validating repository state for OmniGrid sync..."
          
          # Check for submodule issues
          if [[ -f ".gitmodules" ]]; then
            echo "ğŸ“‹ Submodules detected, checking configuration..."
            
            # Validate each submodule URL
            while IFS= read -r line; do
              if [[ "$line" =~ ^[[:space:]]*url[[:space:]]*=[[:space:]]*(.+)$ ]]; then
                URL="${BASH_REMATCH[1]}"
                echo "  Validating URL: $URL"
                
                # Check if URL is accessible (basic validation)
                if [[ "$URL" =~ ^https:// ]]; then
                  # For HTTPS URLs, check format
                  if [[ "$URL" =~ ^https://[^/]+/[^/]+/.+\.git$ ]] || [[ "$URL" =~ ^https://[^/]+/[^/]+/[^/]+$ ]]; then
                    echo "  âœ… URL format valid"
                  else
                    echo "  âš ï¸ URL format may be invalid: $URL"
                  fi
                elif [[ "$URL" =~ ^git@ ]]; then
                  echo "  â„¹ï¸ SSH URL detected: $URL"
                fi
              fi
            done < .gitmodules
            
            echo "has_submodules=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ No submodules configured"
            echo "has_submodules=false" >> $GITHUB_OUTPUT
          fi
          
          # Verify git state is clean
          if git status --porcelain | grep -q '^'; then
            echo "âš ï¸ Working directory has uncommitted changes"
            git status --short
          else
            echo "âœ… Working directory is clean"
          fi
          
          echo "âœ… Repository state validation complete"

      - name: Load ecosystem configuration
        id: config
        run: |
          echo "ğŸ“ Loading ecosystem configuration..."
          if [[ -f "${{ env.ECOSYSTEM_CONFIG }}" ]]; then
            OMNIGRID_REPO=$(jq -r '.repositories[] | select(.role == "infrastructure") | .name' ${{ env.ECOSYSTEM_CONFIG }})
            SYNC_STRATEGY=$(jq -r '.repositories[] | select(.role == "infrastructure") | .sync_strategy' ${{ env.ECOSYSTEM_CONFIG }})
            SYNC_PATTERNS=$(jq -r '.repositories[] | select(.role == "infrastructure") | .sync_patterns | join(",")' ${{ env.ECOSYSTEM_CONFIG }})
            
            echo "omnigrid_repo=$OMNIGRID_REPO" >> $GITHUB_OUTPUT
            echo "sync_strategy=$SYNC_STRATEGY" >> $GITHUB_OUTPUT
            echo "sync_patterns=$SYNC_PATTERNS" >> $GITHUB_OUTPUT
            
            echo "âœ… Target: $OMNIGRID_REPO"
            echo "âœ… Strategy: $SYNC_STRATEGY (selective)"
            echo "âœ… Patterns: $SYNC_PATTERNS"
          else
            echo "âŒ Configuration file not found"
            exit 1
          fi

      - name: Check if branch exists in OmniGrid
        id: check_branch
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸ” Checking if branch exists in OmniGrid..."
          REPO="${{ steps.config.outputs.omnigrid_repo }}"
          BRANCH="${{ matrix.branch }}"
          
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$REPO/branches/$BRANCH")
          
          if [[ "$STATUS_CODE" == "200" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Branch exists in OmniGrid"
          elif [[ "$STATUS_CODE" == "404" ]]; then
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Branch does not exist in OmniGrid (will create)"
          else
            echo "exists=unknown" >> $GITHUB_OUTPUT
            echo "âš ï¸ Unable to determine branch status (HTTP $STATUS_CODE)"
          fi

      - name: Sync branch to OmniGrid (selective)
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸ”„ Syncing branch ${{ matrix.branch }} to OmniGrid (selective)..."
          
          REPO="${{ steps.config.outputs.omnigrid_repo }}"
          BRANCH="${{ matrix.branch }}"
          BRANCH_EXISTS="${{ steps.check_branch.outputs.exists }}"
          
          # Skip if branch status is unknown
          if [[ "$BRANCH_EXISTS" == "unknown" ]]; then
            echo "âš ï¸ Skipping sync due to unknown branch status"
            exit 0
          fi
          
          # Get latest commit SHA
          LATEST_SHA=$(git rev-parse HEAD)
          echo "ğŸ“Œ Latest commit: $LATEST_SHA"
          
          if [[ "$BRANCH_EXISTS" == "false" ]]; then
            echo "ğŸŒ± Creating new branch in OmniGrid..."
            
            DEFAULT_BRANCH=$(curl -s \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO" | jq -r '.default_branch')
            
            BASE_SHA=$(curl -s \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/git/ref/heads/$DEFAULT_BRANCH" | jq -r '.object.sha')
            
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/git/refs" \
              -d "{\"ref\":\"refs/heads/$BRANCH\",\"sha\":\"$BASE_SHA\"}"
            
            echo "âœ… Branch created in OmniGrid"
          fi
          
          # Trigger selective sync via repository dispatch
          echo "ğŸ“¤ Triggering selective sync in OmniGrid..."
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$REPO/dispatches" \
            -d "{\"event_type\":\"selective_sync_from_fruitful\",\"client_payload\":{\"branch\":\"$BRANCH\",\"source_repo\":\"$GITHUB_REPOSITORY\",\"source_sha\":\"$LATEST_SHA\",\"patterns\":\"${{ steps.config.outputs.sync_patterns }}\"}}"
          
          echo "âœ… Selective sync request sent to OmniGrid"

      - name: Record sync event
        if: always()
        run: |
          echo "ğŸ“Š Recording sync event..."
          echo "Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "Branch: ${{ matrix.branch }}"
          echo "Target: OmniGrid"
          echo "Status: ${{ job.status }}"

  sync-summary:
    name: ğŸ“Š Sync Summary
    needs: [detect-changes, sync-to-codenest, sync-to-omnigrid]
    if: always() && needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate sync summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘          Cross-Repository Synchronization Summary             â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "â° Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "ğŸ“Œ Sync Mode: ${{ needs.detect-changes.outputs.sync_mode }}"
          echo "ğŸŒ¿ Branches: ${{ needs.detect-changes.outputs.branches_to_sync }}"
          echo ""
          echo "ğŸ“Š Results:"
          echo "  ğŸ¦ CodeNest sync: ${{ needs.sync-to-codenest.result }}"
          echo "  ğŸ”· OmniGrid sync: ${{ needs.sync-to-omnigrid.result }}"
          echo ""
          
          if [[ "${{ needs.sync-to-codenest.result }}" == "success" ]] && [[ "${{ needs.sync-to-omnigrid.result }}" == "success" ]]; then
            echo "âœ… All repositories synchronized successfully!"
          else
            echo "âš ï¸ Some synchronization jobs had issues. Check logs for details."
          fi
          
          echo ""
          echo "ğŸ”„ Next sync: In 15 minutes (scheduled)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Update sync cache
        uses: actions/cache/save@v3
        with:
          path: |
            .git
          key: ecosystem-sync-${{ github.sha }}-${{ github.run_id }}
