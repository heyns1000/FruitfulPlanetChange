name: ‚ÜîÔ∏è Bidirectional Repository Sync

permissions:
  contents: write
  pull-requests: write
  issues: write

on:
  repository_dispatch:
    types:
      - sync_from_codenest
      - sync_from_omnigrid
  schedule:
    # Check for updates from other repos every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      source_repo:
        description: 'Source repository (codenest or omnigrid)'
        required: true
        type: choice
        options:
          - codenest
          - omnigrid
          - both
        default: both
      branch:
        description: 'Branch to sync (leave empty for all)'
        required: false
        default: ''

env:
  ECOSYSTEM_CONFIG: '.github/ecosystem-config.json'

jobs:
  detect-upstream-changes:
    name: üîç Detect Upstream Changes
    runs-on: ubuntu-latest
    outputs:
      codenest_changes: ${{ steps.check.outputs.codenest_changes }}
      omnigrid_changes: ${{ steps.check.outputs.omnigrid_changes }}
      branches_to_sync: ${{ steps.check.outputs.branches }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          submodules: false  # Explicitly disable automatic submodule updates

      - name: Check for submodule configuration
        id: check_submodules
        continue-on-error: true
        run: |
          echo "üîç Checking for submodule configuration..."
          
          if [[ -f ".gitmodules" ]]; then
            echo "üìã .gitmodules file found, validating..."
            echo "has_submodules=true" >> $GITHUB_OUTPUT
            
            # Validate submodule URLs
            while IFS= read -r line; do
              if [[ "$line" =~ ^[[:space:]]*url[[:space:]]*=[[:space:]]*(.+)$ ]]; then
                URL="${BASH_REMATCH[1]}"
                echo "  Checking URL: $URL"
                
                # Validate URL format
                if [[ "$URL" =~ ^(https://|git@) ]]; then
                  echo "  ‚úÖ Valid URL format"
                else
                  echo "  ‚ö†Ô∏è Warning: Potentially invalid URL format"
                fi
              fi
            done < .gitmodules
          else
            echo "‚ÑπÔ∏è No .gitmodules file found"
            echo "has_submodules=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for orphaned submodule config
          if git config --file .git/config --get-regexp submodule >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Warning: Submodule config exists in .git/config but no .gitmodules file"
            echo "  This may cause issues. Attempting to clean up..."
            git config --file .git/config --remove-section submodule 2>/dev/null || true
          fi

      - name: Load ecosystem configuration
        id: config
        run: |
          echo "üìù Loading ecosystem configuration..."
          CODENEST_REPO=$(jq -r '.repositories[] | select(.role == "meta-aggregator") | .name' ${{ env.ECOSYSTEM_CONFIG }})
          OMNIGRID_REPO=$(jq -r '.repositories[] | select(.role == "infrastructure") | .name' ${{ env.ECOSYSTEM_CONFIG }})
          
          echo "codenest_repo=$CODENEST_REPO" >> $GITHUB_OUTPUT
          echo "omnigrid_repo=$OMNIGRID_REPO" >> $GITHUB_OUTPUT

      - name: Check for upstream changes
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Checking for upstream changes..."
          
          SOURCE="${{ github.event.inputs.source_repo || 'both' }}"
          CODENEST_REPO="${{ steps.config.outputs.codenest_repo }}"
          OMNIGRID_REPO="${{ steps.config.outputs.omnigrid_repo }}"
          
          CODENEST_CHANGES=false
          OMNIGRID_CHANGES=false
          BRANCHES="[]"
          
          # Check CodeNest
          if [[ "$SOURCE" == "codenest" ]] || [[ "$SOURCE" == "both" ]]; then
            echo "Checking CodeNest for changes..."
            
            # Get branches from CodeNest
            CODENEST_BRANCHES=$(curl -s \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$CODENEST_REPO/branches" | \
              jq -r '.[].name' | grep -E '^(copilot|claude|main|develop)' | jq -R -s -c 'split("\n") | map(select(length > 0))')
            
            if [[ "$CODENEST_BRANCHES" != "[]" ]]; then
              CODENEST_CHANGES=true
              BRANCHES="$CODENEST_BRANCHES"
              echo "‚úÖ Found changes in CodeNest"
            fi
          fi
          
          # Check OmniGrid
          if [[ "$SOURCE" == "omnigrid" ]] || [[ "$SOURCE" == "both" ]]; then
            echo "Checking OmniGrid for changes..."
            
            OMNIGRID_BRANCHES=$(curl -s \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$OMNIGRID_REPO/branches" | \
              jq -r '.[].name' | grep -E '^(copilot|claude|main|develop)' | jq -R -s -c 'split("\n") | map(select(length > 0))')
            
            if [[ "$OMNIGRID_BRANCHES" != "[]" ]]; then
              OMNIGRID_CHANGES=true
              # Merge with existing branches
              BRANCHES=$(echo "$BRANCHES $OMNIGRID_BRANCHES" | jq -s 'add | unique')
              echo "‚úÖ Found changes in OmniGrid"
            fi
          fi
          
          echo "codenest_changes=$CODENEST_CHANGES" >> $GITHUB_OUTPUT
          echo "omnigrid_changes=$OMNIGRID_CHANGES" >> $GITHUB_OUTPUT
          echo "branches=$BRANCHES" >> $GITHUB_OUTPUT
          
          echo "üìä Summary:"
          echo "  CodeNest has changes: $CODENEST_CHANGES"
          echo "  OmniGrid has changes: $OMNIGRID_CHANGES"
          echo "  Branches to sync: $BRANCHES"

  sync-from-codenest:
    name: ü¶ç Sync from CodeNest
    needs: detect-upstream-changes
    if: needs.detect-upstream-changes.outputs.codenest_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        branch: ${{ fromJson(needs.detect-upstream-changes.outputs.branches_to_sync) }}
      fail-fast: false
      max-parallel: 3
    steps:
      - name: Checkout FruitfulPlanetChange
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.branch }}
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          submodules: false  # Explicitly disable automatic submodule updates

      - name: Setup Git
        run: |
          git config --global user.name "HSOMNI9000 Sync Bot"
          git config --global user.email "sync-bot@fruitfulplanet.com"

      - name: Validate repository state
        id: validate
        continue-on-error: true
        run: |
          echo "üîç Validating repository state..."
          
          # Check for submodule issues
          if [[ -f ".gitmodules" ]]; then
            echo "üìã Submodules detected, checking configuration..."
            
            # Validate each submodule URL
            while IFS= read -r line; do
              if [[ "$line" =~ ^[[:space:]]*url[[:space:]]*=[[:space:]]*(.+)$ ]]; then
                URL="${BASH_REMATCH[1]}"
                echo "  Validating URL: $URL"
                
                # Check if URL is accessible (basic validation)
                if [[ "$URL" =~ ^https:// ]]; then
                  # For HTTPS URLs, check format
                  if [[ "$URL" =~ ^https://[^/]+/[^/]+/.+\.git$ ]] || [[ "$URL" =~ ^https://[^/]+/[^/]+/[^/]+$ ]]; then
                    echo "  ‚úÖ URL format valid"
                  else
                    echo "  ‚ö†Ô∏è URL format may be invalid: $URL"
                  fi
                elif [[ "$URL" =~ ^git@ ]]; then
                  echo "  ‚ÑπÔ∏è SSH URL detected: $URL"
                fi
              fi
            done < .gitmodules
          else
            echo "‚ÑπÔ∏è No submodules configured"
          fi
          
          echo "‚úÖ Repository state validation complete"

      - name: Load ecosystem configuration
        id: config
        run: |
          CODENEST_REPO=$(jq -r '.repositories[] | select(.role == "meta-aggregator") | .name' ${{ env.ECOSYSTEM_CONFIG }})
          echo "codenest_repo=$CODENEST_REPO" >> $GITHUB_OUTPUT

      - name: Fetch CodeNest changes
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üì• Fetching changes from CodeNest..."
          REPO="${{ steps.config.outputs.codenest_repo }}"
          BRANCH="${{ matrix.branch }}"
          
          # Add CodeNest as remote if not exists
          if ! git remote | grep -q "^codenest$"; then
            git remote add codenest "https://x-access-token:$GITHUB_TOKEN@github.com/$REPO.git"
          fi
          
          git fetch codenest "$BRANCH" || {
            echo "‚ö†Ô∏è Branch $BRANCH not found in CodeNest, skipping..."
            exit 0
          }
          
          echo "‚úÖ Fetched changes from CodeNest"

      - name: Compare and merge changes
        id: merge
        run: |
          echo "üîÑ Comparing changes..."
          BRANCH="${{ matrix.branch }}"
          
          # Check if we're ahead, behind, or diverged
          LOCAL_SHA=$(git rev-parse HEAD)
          REMOTE_SHA=$(git rev-parse codenest/$BRANCH 2>/dev/null || echo "")
          
          if [[ -z "$REMOTE_SHA" ]]; then
            echo "status=no_remote" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No remote branch in CodeNest"
            exit 0
          fi
          
          if [[ "$LOCAL_SHA" == "$REMOTE_SHA" ]]; then
            echo "status=synced" >> $GITHUB_OUTPUT
            echo "‚úÖ Already in sync"
            exit 0
          fi
          
          # Try to merge
          echo "üîÄ Attempting to merge changes..."
          if git merge codenest/$BRANCH --no-edit; then
            echo "status=merged" >> $GITHUB_OUTPUT
            echo "‚úÖ Successfully merged changes"
          else
            echo "status=conflict" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Merge conflict detected"
            
            # Auto-resolve with 'ours' strategy for simple conflicts
            git merge --strategy-option=ours codenest/$BRANCH || {
              echo "‚ùå Cannot auto-resolve conflict"
              git merge --abort
              exit 0
            }
            
            echo "‚úÖ Auto-resolved conflict with 'ours' strategy"
          fi

      - name: Push changes
        if: steps.merge.outputs.status == 'merged'
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üì§ Pushing merged changes..."
          git push origin ${{ matrix.branch }}
          echo "‚úÖ Changes pushed successfully"

      - name: Create conflict resolution PR
        if: steps.merge.outputs.status == 'conflict'
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÄ Creating conflict resolution PR..."
          
          BRANCH="${{ matrix.branch }}"
          CONFLICT_BRANCH="sync/conflict-resolution/$BRANCH-$(date +%s)"
          
          # Create a new branch for conflict resolution
          git checkout -b "$CONFLICT_BRANCH"
          git push origin "$CONFLICT_BRANCH"
          
          # Create PR using GitHub API
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$GITHUB_REPOSITORY/pulls" \
            -d "{
              \"title\":\"üîÄ Resolve sync conflict: $BRANCH\",
              \"body\":\"Automatic sync from CodeNest detected conflicts that require manual resolution.\\n\\nBranch: \`$BRANCH\`\\nSource: CodeNest\\nConflict Branch: \`$CONFLICT_BRANCH\`\",
              \"head\":\"$CONFLICT_BRANCH\",
              \"base\":\"$BRANCH\",
              \"labels\":[\"conflict-resolution\",\"automated-sync\",\"needs-review\"]
            }"
          
          echo "‚úÖ Conflict resolution PR created"

  sync-from-omnigrid:
    name: üî∑ Sync from OmniGrid
    needs: detect-upstream-changes
    if: needs.detect-upstream-changes.outputs.omnigrid_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        branch: ${{ fromJson(needs.detect-upstream-changes.outputs.branches_to_sync) }}
      fail-fast: false
      max-parallel: 3
    steps:
      - name: Checkout FruitfulPlanetChange
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.branch }}
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          submodules: false  # Explicitly disable automatic submodule updates

      - name: Setup Git
        run: |
          git config --global user.name "HSOMNI9000 Sync Bot"
          git config --global user.email "sync-bot@fruitfulplanet.com"

      - name: Validate repository state
        id: validate
        continue-on-error: true
        run: |
          echo "üîç Validating repository state for OmniGrid sync..."
          
          # Check for submodule issues
          if [[ -f ".gitmodules" ]]; then
            echo "üìã Submodules detected, checking configuration..."
            
            # Validate each submodule URL
            while IFS= read -r line; do
              if [[ "$line" =~ ^[[:space:]]*url[[:space:]]*=[[:space:]]*(.+)$ ]]; then
                URL="${BASH_REMATCH[1]}"
                echo "  Validating URL: $URL"
                
                # Check if URL is accessible (basic validation)
                if [[ "$URL" =~ ^https:// ]]; then
                  # For HTTPS URLs, check format
                  if [[ "$URL" =~ ^https://[^/]+/[^/]+/.+\.git$ ]] || [[ "$URL" =~ ^https://[^/]+/[^/]+/[^/]+$ ]]; then
                    echo "  ‚úÖ URL format valid"
                  else
                    echo "  ‚ö†Ô∏è URL format may be invalid: $URL"
                  fi
                elif [[ "$URL" =~ ^git@ ]]; then
                  echo "  ‚ÑπÔ∏è SSH URL detected: $URL"
                fi
              fi
            done < .gitmodules
          else
            echo "‚ÑπÔ∏è No submodules configured"
          fi
          
          echo "‚úÖ Repository state validation complete"

      - name: Load ecosystem configuration
        id: config
        run: |
          OMNIGRID_REPO=$(jq -r '.repositories[] | select(.role == "infrastructure") | .name' ${{ env.ECOSYSTEM_CONFIG }})
          SYNC_PATTERNS=$(jq -r '.repositories[] | select(.role == "infrastructure") | .sync_patterns | join(" ")' ${{ env.ECOSYSTEM_CONFIG }})
          
          echo "omnigrid_repo=$OMNIGRID_REPO" >> $GITHUB_OUTPUT
          echo "sync_patterns=$SYNC_PATTERNS" >> $GITHUB_OUTPUT

      - name: Fetch OmniGrid changes (selective)
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üì• Fetching selective changes from OmniGrid..."
          REPO="${{ steps.config.outputs.omnigrid_repo }}"
          BRANCH="${{ matrix.branch }}"
          PATTERNS="${{ steps.config.outputs.sync_patterns }}"
          
          # Add OmniGrid as remote
          if ! git remote | grep -q "^omnigrid$"; then
            git remote add omnigrid "https://x-access-token:$GITHUB_TOKEN@github.com/$REPO.git"
          fi
          
          git fetch omnigrid "$BRANCH" || {
            echo "‚ö†Ô∏è Branch $BRANCH not found in OmniGrid, skipping..."
            exit 0
          }
          
          echo "‚úÖ Fetched changes from OmniGrid"

      - name: Selective merge from OmniGrid
        id: merge
        run: |
          echo "üîÑ Performing selective merge..."
          BRANCH="${{ matrix.branch }}"
          PATTERNS="${{ steps.config.outputs.sync_patterns }}"
          
          # Checkout specific paths from OmniGrid
          for pattern in $PATTERNS; do
            echo "üìÇ Syncing pattern: $pattern"
            git checkout omnigrid/$BRANCH -- $pattern 2>/dev/null || {
              echo "‚ÑπÔ∏è Pattern $pattern not found in OmniGrid"
            }
          done
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "status=no_changes" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No changes to sync from OmniGrid"
          else
            git commit -m "chore: sync from OmniGrid (selective) - $BRANCH"
            echo "status=committed" >> $GITHUB_OUTPUT
            echo "‚úÖ Changes committed"
          fi

      - name: Push changes
        if: steps.merge.outputs.status == 'committed'
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üì§ Pushing selective sync changes..."
          git push origin ${{ matrix.branch }}
          echo "‚úÖ Changes pushed successfully"

  generate-sync-report:
    name: üìä Generate Sync Report
    needs: [detect-upstream-changes, sync-from-codenest, sync-from-omnigrid]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: false  # Explicitly disable automatic submodule updates

      - name: Generate report
        run: |
          mkdir -p /tmp/sync-reports
          REPORT_FILE="/tmp/sync-reports/bidirectional-sync-$(date +%Y%m%d-%H%M%S).json"
          
          cat > "$REPORT_FILE" << EOF
          {
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "workflow_run_id": "${{ github.run_id }}",
            "trigger": "${{ github.event_name }}",
            "codenest": {
              "had_changes": "${{ needs.detect-upstream-changes.outputs.codenest_changes }}",
              "sync_status": "${{ needs.sync-from-codenest.result }}"
            },
            "omnigrid": {
              "had_changes": "${{ needs.detect-upstream-changes.outputs.omnigrid_changes }}",
              "sync_status": "${{ needs.sync-from-omnigrid.result }}"
            },
            "branches": ${{ needs.detect-upstream-changes.outputs.branches_to_sync }}
          }
          EOF
          
          echo "üìÑ Sync Report:"
          cat "$REPORT_FILE" | jq '.'

      - name: Upload sync report
        uses: actions/upload-artifact@v4
        with:
          name: bidirectional-sync-report-${{ github.run_id }}
          path: /tmp/sync-reports/
          retention-days: 30

      - name: Summary
        run: |
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë         Bidirectional Synchronization Summary                 ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "‚è∞ Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo ""
          echo "üìä Sync Results:"
          echo "  ü¶ç From CodeNest: ${{ needs.sync-from-codenest.result }}"
          echo "  üî∑ From OmniGrid: ${{ needs.sync-from-omnigrid.result }}"
          echo ""
          echo "üåø Branches synced: ${{ needs.detect-upstream-changes.outputs.branches_to_sync }}"
          echo ""
          
          if [[ "${{ needs.sync-from-codenest.result }}" == "success" ]] && [[ "${{ needs.sync-from-omnigrid.result }}" == "success" ]]; then
            echo "‚úÖ Bidirectional sync completed successfully!"
          elif [[ "${{ needs.sync-from-codenest.result }}" == "skipped" ]] && [[ "${{ needs.sync-from-omnigrid.result }}" == "skipped" ]]; then
            echo "‚ÑπÔ∏è No changes detected in upstream repositories"
          else
            echo "‚ö†Ô∏è Some sync operations had issues. Check artifacts for details."
          fi
          
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  trigger-branch-ahead-sync:
    name: üöÄ Trigger Keep-Branches-Ahead Sync
    needs: [sync-from-codenest, sync-from-omnigrid]
    if: always() && (needs.sync-from-codenest.result == 'success' || needs.sync-from-omnigrid.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: false  # Explicitly disable automatic submodule updates

      - name: Trigger keep-branches-ahead workflow
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üöÄ Triggering keep-branches-ahead workflow..."
          
          # Trigger the workflow using repository_dispatch
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/dispatches" \
            -d '{
              "event_type": "trigger_branch_sync",
              "client_payload": {
                "triggered_by": "bidirectional-sync",
                "workflow_run_id": "${{ github.run_id }}",
                "timestamp": "'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'"
              }
            }'
          
          echo "‚úÖ Keep-branches-ahead workflow triggered successfully"
          echo "‚ÑπÔ∏è This ensures all branches stay ahead of main after bidirectional sync"
