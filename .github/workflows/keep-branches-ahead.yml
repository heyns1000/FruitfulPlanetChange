name: üîÑ Keep Branches Ahead of Main

on:
  schedule:
    # Run every 2 hours
    - cron: '0 */2 * * *'
  
  push:
    branches:
      - main
  
  repository_dispatch:
    types:
      - trigger_branch_sync
  
  workflow_dispatch:
    inputs:
      branch_filter:
        description: 'Branch pattern to sync (leave empty for all)'
        required: false
        default: ''
        type: string
      force_sync:
        description: 'Force sync even if already up-to-date'
        required: false
        default: false
        type: boolean

env:
  BRANCH_PATTERNS: 'copilot/* claude/* feature/* fix/* hotfix/* develop'
  EXCLUDE_BRANCHES: 'main gh-pages production'
  AUTO_MERGE_ENABLED: true
  CONFLICT_PR_ENABLED: true
  MAX_PARALLEL_SYNCS: 5
  ECOSYSTEM_CONFIG: '.github/ecosystem-config.json'
  SYNC_CONFIG: '.github/sync-config.yml'

jobs:
  detect-branches:
    name: üîç Detect Branches to Sync
    runs-on: ubuntu-latest
    outputs:
      branches_matrix: ${{ steps.detect.outputs.branches_matrix }}
      total_branches: ${{ steps.detect.outputs.total_branches }}
      has_branches: ${{ steps.detect.outputs.has_branches }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Detect active branches
        id: detect
        run: |
          echo "üîç Detecting branches that need syncing..."
          
          # Get all remote branches
          git fetch --all --prune
          
          # Define patterns from config
          PATTERNS="${{ github.event.inputs.branch_filter || env.BRANCH_PATTERNS }}"
          EXCLUDE="${{ env.EXCLUDE_BRANCHES }}"
          
          # Collect branches
          BRANCHES=()
          
          for pattern in $PATTERNS; do
            echo "üìã Checking pattern: $pattern"
            
            # Handle wildcard patterns
            if [[ "$pattern" == *"*"* ]]; then
              # Extract prefix (e.g., "copilot/" from "copilot/*")
              prefix="${pattern%\*}"
              matching=$(git branch -r | grep "origin/$prefix" | sed 's|origin/||' | sed 's/^[[:space:]]*//' || echo "")
            else
              # Exact branch name
              matching=$(git branch -r | grep -E "origin/$pattern$" | sed 's|origin/||' | sed 's/^[[:space:]]*//' || echo "")
            fi
            
            if [[ -n "$matching" ]]; then
              while IFS= read -r branch; do
                [[ -n "$branch" ]] && BRANCHES+=("$branch")
              done <<< "$matching"
            fi
          done
          
          # Remove duplicates and excluded branches
          UNIQUE_BRANCHES=($(printf '%s\n' "${BRANCHES[@]}" | sort -u))
          FILTERED_BRANCHES=()
          
          for branch in "${UNIQUE_BRANCHES[@]}"; do
            excluded=false
            for exclude_pattern in $EXCLUDE; do
              if [[ "$branch" == "$exclude_pattern" ]] || [[ "$branch" == $exclude_pattern ]]; then
                excluded=true
                break
              fi
            done
            
            if [[ "$excluded" == "false" ]]; then
              FILTERED_BRANCHES+=("$branch")
            fi
          done
          
          # Convert to JSON array for matrix
          BRANCHES_JSON="["
          first=true
          for branch in "${FILTERED_BRANCHES[@]}"; do
            if [[ "$first" == "true" ]]; then
              first=false
            else
              BRANCHES_JSON+=","
            fi
            BRANCHES_JSON+="\"$branch\""
          done
          BRANCHES_JSON+="]"
          
          echo "branches_matrix=$BRANCHES_JSON" >> $GITHUB_OUTPUT
          echo "total_branches=${#FILTERED_BRANCHES[@]}" >> $GITHUB_OUTPUT
          
          if [[ ${#FILTERED_BRANCHES[@]} -gt 0 ]]; then
            echo "has_branches=true" >> $GITHUB_OUTPUT
          else
            echo "has_branches=false" >> $GITHUB_OUTPUT
          fi
          
          echo "‚úÖ Found ${#FILTERED_BRANCHES[@]} branches to check:"
          printf '  - %s\n' "${FILTERED_BRANCHES[@]}"

  check-branch-status:
    name: ‚úÖ Check Branch Status
    needs: detect-branches
    if: needs.detect-branches.outputs.has_branches == 'true'
    runs-on: ubuntu-latest
    outputs:
      branches_to_sync: ${{ steps.check.outputs.branches_to_sync }}
      branches_count: ${{ steps.check.outputs.branches_count }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Check which branches are behind main
        id: check
        run: |
          echo "üîç Checking which branches are behind main..."
          
          git fetch origin main
          MAIN_SHA=$(git rev-parse origin/main)
          echo "üìå Main SHA: $MAIN_SHA"
          
          BRANCHES_JSON='${{ needs.detect-branches.outputs.branches_matrix }}'
          BRANCHES_TO_SYNC=()
          
          # Parse JSON array
          BRANCHES=($(echo "$BRANCHES_JSON" | jq -r '.[]'))
          
          for branch in "${BRANCHES[@]}"; do
            echo "Checking $branch..."
            
            # Fetch the branch
            git fetch origin "$branch" 2>/dev/null || {
              echo "‚ö†Ô∏è Could not fetch $branch, skipping..."
              continue
            }
            
            BRANCH_SHA=$(git rev-parse "origin/$branch")
            
            # Check if branch contains main
            if git merge-base --is-ancestor origin/main "origin/$branch" 2>/dev/null; then
              if [[ "${{ github.event.inputs.force_sync }}" == "true" ]]; then
                echo "üîÑ $branch is up-to-date but force_sync enabled"
                BRANCHES_TO_SYNC+=("$branch")
              else
                echo "‚úÖ $branch is already ahead of main"
              fi
            else
              echo "‚¨ÜÔ∏è $branch is behind main and needs sync"
              BRANCHES_TO_SYNC+=("$branch")
            fi
          done
          
          # Convert to JSON
          SYNC_JSON="["
          first=true
          for branch in "${BRANCHES_TO_SYNC[@]}"; do
            if [[ "$first" == "true" ]]; then
              first=false
            else
              SYNC_JSON+=","
            fi
            SYNC_JSON+="\"$branch\""
          done
          SYNC_JSON+="]"
          
          echo "branches_to_sync=$SYNC_JSON" >> $GITHUB_OUTPUT
          echo "branches_count=${#BRANCHES_TO_SYNC[@]}" >> $GITHUB_OUTPUT
          
          echo ""
          echo "üìä Summary: ${#BRANCHES_TO_SYNC[@]} branches need syncing"

  sync-branches:
    name: üîÑ Sync Branch with Main
    needs: check-branch-status
    if: needs.check-branch-status.outputs.branches_count != '0'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        branch: ${{ fromJson(needs.check-branch-status.outputs.branches_to_sync) }}
      fail-fast: false
      max-parallel: 5
    outputs:
      sync_result: ${{ steps.sync.outputs.result }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.branch }}
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "HSOMNI9000 Sync Bot"
          git config --global user.email "sync-bot@fruitfulplanet.com"

      - name: Merge main into branch
        id: sync
        run: |
          echo "üîÑ Syncing ${{ matrix.branch }} with main..."
          
          BRANCH="${{ matrix.branch }}"
          
          # Fetch latest main
          git fetch origin main
          
          # Try to merge main into current branch
          echo "üîÄ Attempting merge with --no-ff strategy..."
          
          if git merge origin/main --no-ff -m "chore(sync): merge main into $BRANCH [automated]" 2>&1 | tee /tmp/merge.log; then
            echo "result=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Successfully merged main into $BRANCH"
            
            # Push the changes
            if git push origin "$BRANCH"; then
              echo "üì§ Changes pushed successfully"
            else
              echo "result=push_failed" >> $GITHUB_OUTPUT
              echo "‚ùå Failed to push changes"
              exit 1
            fi
          else
            # Merge conflict detected
            echo "result=conflict" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Merge conflict detected in $BRANCH"
            
            # Check for auto-resolvable files
            CONFLICTED_FILES=$(git diff --name-only --diff-filter=U)
            echo "üìù Conflicted files:"
            echo "$CONFLICTED_FILES"
            
            # Try auto-resolution for lock files
            AUTO_RESOLVE=true
            while IFS= read -r file; do
              case "$file" in
                *package-lock.json|*pnpm-lock.yaml|*yarn.lock|*.lock|*Cargo.lock|*Gemfile.lock|*composer.lock)
                  echo "üîß Auto-resolving lock file: $file (using theirs)"
                  git checkout --theirs "$file"
                  git add "$file"
                  ;;
                *)
                  AUTO_RESOLVE=false
                  echo "‚ö†Ô∏è Cannot auto-resolve: $file"
                  ;;
              esac
            done <<< "$CONFLICTED_FILES"
            
            if [[ "$AUTO_RESOLVE" == "true" ]]; then
              # All conflicts auto-resolved
              if git commit --no-edit; then
                echo "result=auto_resolved" >> $GITHUB_OUTPUT
                echo "‚úÖ Auto-resolved conflicts and committed"
                git push origin "$BRANCH"
                exit 0
              fi
            fi
            
            # Abort merge and let conflict handler deal with it
            git merge --abort
            echo "result=needs_manual_resolution" >> $GITHUB_OUTPUT
            echo "üìã Conflict needs manual resolution - PR will be created"
          fi

  handle-conflicts:
    name: üîÄ Handle Merge Conflicts
    needs: [check-branch-status, sync-branches]
    if: always() && needs.sync-branches.result != 'success' && needs.sync-branches.result != 'skipped'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        branch: ${{ fromJson(needs.check-branch-status.outputs.branches_to_sync) }}
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.branch }}
          fetch-depth: 0
          token: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "HSOMNI9000 Sync Bot"
          git config --global user.email "sync-bot@fruitfulplanet.com"

      - name: Create conflict resolution branch and PR
        env:
          GITHUB_TOKEN: ${{ secrets.ECOSYSTEM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÄ Creating conflict resolution PR for ${{ matrix.branch }}..."
          
          BRANCH="${{ matrix.branch }}"
          TIMESTAMP=$(date +%s)
          CONFLICT_BRANCH="sync/conflict-resolution/${BRANCH//\//-}-$TIMESTAMP"
          
          # Fetch main
          git fetch origin main
          
          # Create a new branch from current branch
          git checkout -b "$CONFLICT_BRANCH"
          
          # Attempt merge to capture conflict info
          git merge origin/main --no-commit --no-ff 2>&1 | tee /tmp/conflict_info.txt || true
          
          # Get list of conflicted files
          CONFLICTED_FILES=$(git diff --name-only --diff-filter=U | tr '\n' ',' | sed 's/,$//')
          
          # Abort the merge
          git merge --abort || true
          
          # Push the conflict branch
          git push origin "$CONFLICT_BRANCH"
          
          # Create PR title and body
          PR_TITLE="Resolve merge conflict: $BRANCH from main"
          
          # Create PR using GitHub API
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d @- <<JSONEOF
          {
            "title": "üîÄ $PR_TITLE",
            "body": "## üîÄ Automatic Sync Conflict Resolution Needed\n\n**Branch:** \`$BRANCH\`\n**Source:** \`main\`\n**Conflict Branch:** \`$CONFLICT_BRANCH\`\n**Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n\n### ‚ö†Ô∏è Merge Conflicts Detected\n\nThe automated sync from \`main\` to \`$BRANCH\` detected conflicts that require manual resolution.\n\n**Conflicted Files:** $CONFLICTED_FILES\n\n### üìã Resolution Steps\n\n1. Checkout this conflict resolution branch\n2. Merge main and resolve conflicts\n3. Push and merge this PR\n\n### ü§ñ Automated by HSOMNI9000 Sync Bot",
            "head": "$CONFLICT_BRANCH",
            "base": "$BRANCH",
            "draft": false
          }
          JSONEOF
          
          PR_NUMBER=$(curl -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" | \
            jq -r ".[] | select(.head.ref == \"$CONFLICT_BRANCH\") | .number" | head -1)
          
          if [[ -n "$PR_NUMBER" ]]; then
            echo "‚úÖ Conflict resolution PR #$PR_NUMBER created successfully"
            
            # Add labels
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/issues/$PR_NUMBER/labels" \
              -d '{"labels":["conflict-resolution","automated-sync","needs-review"]}'
            
            echo "üè∑Ô∏è Labels added to PR #$PR_NUMBER"
          else
            echo "‚ùå Failed to create or find PR"
            exit 1
          fi

  generate-report:
    name: üìä Generate Sync Report
    needs: [detect-branches, check-branch-status, sync-branches, handle-conflicts]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate comprehensive sync report
        run: |
          mkdir -p /tmp/sync-reports
          REPORT_FILE="/tmp/sync-reports/keep-branches-ahead-$(date +%Y%m%d-%H%M%S).json"
          
          cat > "$REPORT_FILE" << EOF
          {
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "trigger": "${{ github.event_name }}",
            "trigger_input": {
              "branch_filter": "${{ github.event.inputs.branch_filter || 'all' }}",
              "force_sync": "${{ github.event.inputs.force_sync || 'false' }}"
            },
            "detection": {
              "total_branches_detected": "${{ needs.detect-branches.outputs.total_branches || '0' }}",
              "branches_detected": ${{ needs.detect-branches.outputs.branches_matrix || '[]' }}
            },
            "status_check": {
              "branches_needing_sync": "${{ needs.check-branch-status.outputs.branches_count || '0' }}",
              "branches_to_sync": ${{ needs.check-branch-status.outputs.branches_to_sync || '[]' }}
            },
            "sync_results": {
              "sync_job_status": "${{ needs.sync-branches.result }}",
              "conflict_handler_status": "${{ needs.handle-conflicts.result }}"
            },
            "statistics": {
              "detection_status": "${{ needs.detect-branches.result }}",
              "check_status": "${{ needs.check-branch-status.result }}",
              "overall_success": "${{ needs.sync-branches.result == 'success' || needs.sync-branches.result == 'skipped' }}"
            }
          }
          EOF
          
          echo "üìÑ Sync Report Generated:"
          cat "$REPORT_FILE" | jq '.'
          
          # Create a summary file
          SUMMARY_FILE="/tmp/sync-reports/summary.txt"
          cat > "$SUMMARY_FILE" << EOF
          ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
          ‚ïë           Keep Branches Ahead - Sync Summary                   ‚ïë
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
          
          ‚è∞ Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          üîó Workflow Run: ${{ github.run_id }}
          üéØ Trigger: ${{ github.event_name }}
          
          üìä Statistics:
            üîç Branches Detected: ${{ needs.detect-branches.outputs.total_branches || '0' }}
            ‚¨ÜÔ∏è Branches Behind Main: ${{ needs.check-branch-status.outputs.branches_count || '0' }}
            ‚úÖ Sync Job Status: ${{ needs.sync-branches.result }}
            üîÄ Conflict Handler Status: ${{ needs.handle-conflicts.result }}
          
          EOF
          
          if [[ "${{ needs.detect-branches.outputs.has_branches }}" == "false" ]]; then
            echo "‚ÑπÔ∏è No branches matched the configured patterns" >> "$SUMMARY_FILE"
          elif [[ "${{ needs.check-branch-status.outputs.branches_count }}" == "0" ]]; then
            echo "‚úÖ All branches are already up-to-date with main!" >> "$SUMMARY_FILE"
          elif [[ "${{ needs.sync-branches.result }}" == "success" ]]; then
            echo "‚úÖ All branches successfully synced with main!" >> "$SUMMARY_FILE"
          else
            echo "‚ö†Ô∏è Some branches encountered issues. Check the logs and conflict PRs." >> "$SUMMARY_FILE"
          fi
          
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$SUMMARY_FILE"
          
          cat "$SUMMARY_FILE"

      - name: Upload sync reports
        uses: actions/upload-artifact@v4
        with:
          name: keep-branches-ahead-report-${{ github.run_id }}
          path: /tmp/sync-reports/
          retention-days: 30

      - name: Create GitHub Actions Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## üîÑ Keep Branches Ahead - Sync Summary
          
          **Workflow Run:** #${{ github.run_id }}  
          **Triggered by:** ${{ github.event_name }}  
          **Timestamp:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          ### üìä Results
          
          | Metric | Value |
          |--------|-------|
          | üîç Branches Detected | ${{ needs.detect-branches.outputs.total_branches || '0' }} |
          | ‚¨ÜÔ∏è Branches Behind Main | ${{ needs.check-branch-status.outputs.branches_count || '0' }} |
          | ‚úÖ Sync Status | ${{ needs.sync-branches.result }} |
          | üîÄ Conflict Handler | ${{ needs.handle-conflicts.result }} |
          
          ### üåø Branch Status
          
          EOF
          
          if [[ "${{ needs.detect-branches.outputs.has_branches }}" == "false" ]]; then
            echo "‚ÑπÔ∏è No branches matched the configured patterns" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.check-branch-status.outputs.branches_count }}" == "0" ]]; then
            echo "‚úÖ All detected branches are already up-to-date with main!" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.sync-branches.result }}" == "success" ]]; then
            echo "‚úÖ All branches successfully synced with main!" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Some branches encountered conflicts. Conflict resolution PRs have been created." >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          
          ---
          
          ü§ñ *Automated by HSOMNI9000 Enhanced Branch Synchronization System*
          EOF
